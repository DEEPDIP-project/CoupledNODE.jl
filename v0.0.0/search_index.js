var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = CoupledNODE","category":"page"},{"location":"#CoupledNODE","page":"Home","title":"CoupledNODE","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for CoupledNODE.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [CoupledNODE]","category":"page"},{"location":"#CoupledNODE.lhist","page":"Home","title":"CoupledNODE.lhist","text":"callback(p, l, pred; doplot=true)\n\nThe callback function is used to observe training progress. It prints the current loss value and updates the rolling average of the loss. If do_plot is true, it also plots the rolling average of the loss every 10 steps.\n\nArguments\n\np: the current parameters\nl: the current loss value\npred: the current prediction\ndo_plot: a boolean indicating whether to plot the rolling average of the loss every 10 steps (default is true)\n\nReturns\n\nfalse if nothing unexpected happened.\n\n\n\n\n\n","category":"constant"},{"location":"#CoupledNODE.Grid","page":"Home","title":"CoupledNODE.Grid","text":"struct Grid\n\nObject containing the grid information. It can handle 1D, 2D, and 3D grids.\n\nFields:\n\ndim::Int: The dimensionality of the grid.\ndx::Union{Float32, Float64}: The grid spacing in the x-direction.\ndy::Union{Float32, Float64}: The grid spacing in the y-direction. Default is 0 for 1D grid.\ndz::Union{Float32, Float64}: The grid spacing in the z-direction. Default is 0 for 1D and 2D grids.\nnx::Int: The number of grid points in the x-direction.\nny::Int: The number of grid points in the y-direction. Default is 0 for 1D grid.\nnz::Int: The number of grid points in the z-direction. Default is 0 for 1D and 2D grids.\nN::Int: The total number of elements in the grid.\n\nConstructor:\n\nGrid(dim::Int, dx::Union{Float32, Float64}, dy::Union{Float32, Float64} = 0, dz::Union{Float32, Float64} = 0, nx::Int, ny::Int = 0, nz::Int = 0, convert_to_float32::Bool = false): Constructs a Grid object with the given grid parameters. The dy, dz, ny, and nz parameters can be omitted for 1D and 2D grids. \n\n\n\n\n\n","category":"type"},{"location":"#CoupledNODE.Concatenate-Tuple{Any}","page":"Home","title":"CoupledNODE.Concatenate","text":"Concatenate(grids)\n\nCreates a function to concatenate the coupled variables to a single vector.\n\nArguments\n\ngrids: A vector or tuple containing the grid(s).\n\nReturns\n\nA list of concatenated coupled variables.\n\n\n\n\n\n","category":"method"},{"location":"#CoupledNODE.Unpack-Tuple{Any}","page":"Home","title":"CoupledNODE.Unpack","text":"Unpack(grids)\n\nCreates a function to unpack the input data from a concatenated list to a tuple.\n\nArguments\n\ngrids: A vector or tuple containing the grid(s).\n\nReturns\n\nA list of the unpacked data (coupled variables)\n\n\n\n\n\n","category":"method"},{"location":"#CoupledNODE.create_f_CNODE","page":"Home","title":"CoupledNODE.create_f_CNODE","text":"create_f_CNODE(forces, grids, NNs = nothing; pre_force = identity,\n    post_force = identity, is_closed = false)\n\nCreate a CoupledNODE (CNODE) function that represents a system of coupled differential equations.\n\nArguments\n\nforces: A vector or tuple of functions representing the forces in the system.\ngrids: A vector or tuple of grids representing the variables in the system.\nNNs: (optional) A vector or tuple of neural networks representing the closure terms in the system. Default is nothing.\npre_force: (optional) A function to be applied before the force layer. Default is identity.\npost_force: (optional) A function to be applied after the force layer. Default is identity.\nis_closed: (optional) A boolean indicating whether the CNODE is closed. Default is false.\n\nReturns\n\nA Chain object representing the consecutive set of operations taking place in the CNODE.\n\n\n\n\n\n","category":"function"},{"location":"#CoupledNODE.create_randloss_MulDtO-Tuple{Any, Any, Any}","page":"Home","title":"CoupledNODE.create_randloss_MulDtO","text":"create_randloss_MulDtO(target; nunroll, nintervals=1, nsamples, λ_c, λ_l1)\n\nCreates a random loss function for the multishooting method with multiple shooting intervals.\n\nArguments\n\ntarget: The target data for the loss function.\ntraining_CNODE: Model CNODE.\nst: state of the neural part.\nnunroll: The number of time steps to unroll.\nnoverlaps: The number of time steps that overlaps between consecutive intervals.\nnintervals: The number of shooting intervals.\nnsamples: The number of samples to select.\nλ_c: The weight for the continuity term. It sets how strongly we make the pieces match (continuity term).\nλ_l1: The coefficient for the L1 regularization term in the loss function.\n\nReturns\n\nrandloss_MulDtO: A random loss function for the multishooting method.\n\n\n\n\n\n","category":"method"},{"location":"#CoupledNODE.create_randloss_derivative-NTuple{4, Any}","page":"Home","title":"CoupledNODE.create_randloss_derivative","text":"create_randloss_derivative(input_data, F_target, f, st; n_use = size(input_data, 2), λ=0, λ_c = 0)\n\nCreate a randomized loss function that compares the derivatives. This is done because using the entire dataset at each iteration would be too expensive.\n\nArguments\n\ninput_data: The input data.\nF_target: The target data.\nf: The model function.\nst: The model state.\nn_use: The number of samples to use for the loss function. Defaults to the number of samples in the input data.\nλ and λ_c: The regularization parameter. Defaults to 0.\n\nReturns\n\nA function that computes the mean squared error loss and takes as input the model parameters.\n\n\n\n\n\n","category":"method"},{"location":"#CoupledNODE.loss_MulDtO_oneset-NTuple{4, Any}","page":"Home","title":"CoupledNODE.loss_MulDtO_oneset","text":"loss_MulDtO_oneset(trajectory, θ; λ_c=1e1, λ_l1=1e1, nunroll, nintervals, nsamples=nsamples)\n\nCompute the loss function for the multiple shooting method with a continuous neural ODE (CNODE) model. Check https://docs.sciml.ai/DiffEqFlux/dev/examples/multiple_shooting/ for more details.\n\nArguments\n\ntrajectory: The trajectory of the system.\nθ: The parameters of the CNODE model.\ntraining_CNODE: Model CNODE.\nλ_c: The weight for the continuity term. It sets how strongly we make the pieces match (continuity term). Default is 1e1.\nλ_l1: The weight for the L1 regularization term. Default is 1e1.\nnunroll: The number of time steps to unroll the trajectory.\nnoverlaps: The number of time steps that overlaps between each consecutive intervals.\nnintervals: The number of intervals to divide the trajectory into.\nnsamples: The number of samples.\n\nReturns\n\nloss: The computed loss value.\n\n\n\n\n\n","category":"method"},{"location":"#CoupledNODE.mean_squared_error-NTuple{7, Any}","page":"Home","title":"CoupledNODE.mean_squared_error","text":"mean_squared_error(f, st, x, y, θ, λ)\n\nRandom a priori loss function. Use this function to train the closure term to reproduce the right hand side.\n\nArguments:\n\nf: Function that represents the model.\nst: State of the model.\nx: Input data.\ny: Target data.\nθ: Parameters of the model.\nλ and λ_c: Regularization parameters.\n\nReturns:\n\ntotal_loss: Mean squared error loss.\n\n\n\n\n\n","category":"method"},{"location":"#CoupledNODE.predict_u_CNODE-NTuple{6, Any}","page":"Home","title":"CoupledNODE.predict_u_CNODE","text":"predict_u_CNODE(uv0, θ, st, nunroll, training_CNODE, tg)\n\nAuxiliary function to solve the NeuralODE. Returns the prediction and the target sliced to nunroll time steps for convenience when calculating the loss.\n\nArguments\n\nuv0: Initial condition(s) for the NeuralODE.\nθ: Parameters of the NeuralODE.\nst: Time steps for the NeuralODE.\nnunroll: Number of time steps in the window.\ntraining_CNODE: CNODE model that solves the NeuralODE.\ntg: Target values.\n\nReturns\n\nsol: Prediction of the NeuralODE sliced to nunroll time steps.\ntg[:, :, 1:nunroll]: Target values sliced to nunroll time steps.\n\n\n\n\n\n","category":"method"}]
}
