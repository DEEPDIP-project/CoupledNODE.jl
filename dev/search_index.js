var documenterSearchIndex = {"docs":
[{"location":"#CoupledNODE","page":"Home","title":"CoupledNODE","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for CoupledNODE.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#CoupledNODE.cnn-Tuple{}","page":"Home","title":"CoupledNODE.cnn","text":"cnn(; setup, radii, channels, activations, use_bias, channel_augmenter = identity, rng = Random.default_rng())\n\nConstructs a convolutional neural network model closure(u, θ) that predicts the commutator error (i.e. closure).\n\nArguments\n\nsetup: IncompressibleNavierStokes.jl setup\nradii: An array (size n_layers) with the radii of the kernels for the convolutional layers. Kernels will be symmetrical of size 2r+1.\nchannels: An array (size n_layers) with channel sizes for the convolutional layers.\nactivations: An array (size n_layers) with activation functions for the convolutional layers.\nuse_bias: An array (size n_layers) with booleans indicating whether to use bias in each convolutional layer.\nrng: A random number generator (default: Random.default_rng()).\n\nReturns\n\nA tuple (chain, params, state) where\n\nchain: The constructed Lux.Chain model.\nparams: The parameters of the model.\nstate: The state of the model.\n\n\n\n\n\n","category":"method"},{"location":"#CoupledNODE.create_loss_priori-Tuple{Any, Any}","page":"Home","title":"CoupledNODE.create_loss_priori","text":"Wrap loss function loss(batch, θ).\n\nThe function loss should take inputs like loss(f, x, y, θ).\n\n\n\n\n\n","category":"method"},{"location":"#CoupledNODE.create_randloss_derivative-NTuple{4, Any}","page":"Home","title":"CoupledNODE.create_randloss_derivative","text":"create_randloss_derivative(input_data, F_target, f, st; n_use = size(input_data, 2), λ=0, λ_c = 0)\n\nCreate a randomized loss function that compares the derivatives. This is done because using the entire dataset at each iteration would be too expensive.\n\nArguments\n\ninput_data: The input data.\nF_target: The target data.\nf: The model function.\nst: The model state.\nn_use: The number of samples to use for the loss function. Defaults to the number of samples in the input data.\nλ and λ_c: The regularization parameter. Defaults to 0.\n\nReturns\n\nA function that computes the mean squared error loss and takes as input the model parameters.\n\n\n\n\n\n","category":"method"},{"location":"#CoupledNODE.decollocate-Tuple{Any}","page":"Home","title":"CoupledNODE.decollocate","text":"Interpolate closure force from volume centers to volume faces.\n\n\n\n\n\n","category":"method"},{"location":"#CoupledNODE.interpolate-Tuple{Any, Any, Any}","page":"Home","title":"CoupledNODE.interpolate","text":"Interpolate velocity components to volume centers.\n\nTODO, D and dir can be parameters istead of arguments I think\n\n\n\n\n\n","category":"method"},{"location":"#CoupledNODE.load_checkpoint-Tuple{Any}","page":"Home","title":"CoupledNODE.load_checkpoint","text":"load_checkpoint(checkfile)\n\nLoad a training checkpoint from the specified file.\n\nArguments\n\ncheckfile::String: The path to the checkpoint file.\n\nReturns\n\ncallbackstate: The state of the callback at the checkpoint.\ntrainstate: The state of the training process at the checkpoint.\nepochs_trained::Int: The number of epochs completed at the checkpoint.\n\nExample\n\ncallbackstate, trainstate, epochs_trained = load_checkpoint(\"checkpoint.jld2\")\n\n\n\n\n\n","category":"method"},{"location":"#CoupledNODE.loss_priori_lux","page":"Home","title":"CoupledNODE.loss_priori_lux","text":"loss_priori_lux(model, ps, st, (x, y))\n\nCompute the loss  as the sum of squared differences between the predicted values and the target values, normalized by the sum of squared target values. Format of function signature and outputs are compatible with the Lux ecosystem.\n\nArguments\n\nmodel: The model to be evaluated.\nps: Parameters for the model.\nst: State of the model.\n(x, y): A tuple where x is the input data and y is the target data.\n\nReturns\n\nloss: The computed loss value.\nst_: The updated state of the model.\n(; y_pred = y_pred): Named tuple containing the predicted values y_pred.\n\n\n\n\n\n","category":"function"},{"location":"#CoupledNODE.mean_squared_error-NTuple{4, Any}","page":"Home","title":"CoupledNODE.mean_squared_error","text":"Compute MSE between f(x, θ, st) and y. The MSE is further divided by normalize(y). This signature has been chosen for compatibility with Lux.\n\n\n\n\n\n","category":"method"},{"location":"#CoupledNODE.mean_squared_error-NTuple{7, Any}","page":"Home","title":"CoupledNODE.mean_squared_error","text":"mean_squared_error(f, st, x, y, θ, λ)\n\nRandom a priori loss function. Use this function to train the closure term to reproduce the right hand side.\n\nArguments:\n\nf: Function that represents the model.\nst: State of the model.\nx: Input data.\ny: Target data.\nθ: Parameters of the model.\nλ and λ_c: Regularization parameters.\n\nReturns:\n\ntotal_loss: Mean squared error loss.\n\n\n\n\n\n","category":"method"},{"location":"#CoupledNODE.namedtupleload-Tuple{Any}","page":"Home","title":"CoupledNODE.namedtupleload","text":"namedtupleload(file)\n\nLoad a JLD2 file and convert it to a named tuple.\n\nArguments\n\nfile::String: The path to the JLD2 file.\n\nReturns\n\nNamedTuple: The contents of the file as a named tuple.\n\n\n\n\n\n","category":"method"},{"location":"#CoupledNODE.save_checkpoint-Tuple{Any, Any, Any}","page":"Home","title":"CoupledNODE.save_checkpoint","text":"save_checkpoint(checkfile, callbackstate, trainstate)\n\nSave the current training state to a checkpoint file.\n\nArguments\n\ncheckfile::String: The path to the checkpoint file.\ncallbackstate: The current state of the callback.\ntrainstate: The current state of the training process.\n\n\n\n\n\n","category":"method"}]
}
