var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = CoupledNODE","category":"page"},{"location":"#CoupledNODE","page":"Home","title":"CoupledNODE","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for CoupledNODE.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [CoupledNODE]","category":"page"},{"location":"#CoupledNODE.cnn-Tuple{}","page":"Home","title":"CoupledNODE.cnn","text":"cnn(; setup, radii, channels, activations, use_bias, channel_augmenter = identity, rng = Random.default_rng())\n\nConstructs a convolutional neural network model closure(u, θ) that predicts the commutator error (i.e. closure).\n\nArguments\n\nsetup: IncompressibleNavierStokes.jl setup\nradii: An array (size n_layers) with the radii of the kernels for the convolutional layers. Kernels will be symmetrical of size 2r+1.\nchannels: An array (size n_layers) with channel sizes for the convolutional layers.\nactivations: An array (size n_layers) with activation functions for the convolutional layers.\nuse_bias: An array (size n_layers) with booleans indicating whether to use bias in each convolutional layer.\nrng: A random number generator (default: Random.default_rng()).\n\nReturns\n\nA tuple (chain, params, state) where\n\nchain: The constructed Lux.Chain model.\nparams: The parameters of the model.\nstate: The state of the model.\n\n\n\n\n\n","category":"method"},{"location":"#CoupledNODE.create_loss_post_lux-Tuple{Any}","page":"Home","title":"CoupledNODE.create_loss_post_lux","text":"create_loss_post_lux(rhs; sciml_solver = Tsit5(), kwargs...)\n\nCreates a loss function for a-posteriori fitting using the given right-hand side (RHS) function rhs. The loss function computes the sum of squared differences between the predicted values and the actual data,  normalized by the sum of squared actual data values.\n\nArguments\n\nrhs::Function: The right-hand side function for the ODE problem.\nsciml_solver::AbstractODEAlgorithm: (Optional) The SciML solver to use for solving the ODE problem. Defaults to Tsit5().\nkwargs...: Additional keyword arguments to pass to the solver.\n\nReturns\n\nloss_function::Function: A function that computes the loss given a model, parameters, state, and data (u, t).\n\nloss_function Arguments\n\nmodel: The model to evaluate.\nps: Parameters for the model.\nst: State of the model.\n(u, t): Tuple containing the data u and time points t.\n\nloss_function Returns\n\nloss: The computed loss value.\nst: The model state (unchanged).\nmetadata::NamedTuple: A named tuple containing the predicted values y_pred.\n\nThis makes it compatible with the Lux ecosystem.\n\n\n\n\n\n","category":"method"},{"location":"#CoupledNODE.create_loss_priori-Tuple{Any, Any}","page":"Home","title":"CoupledNODE.create_loss_priori","text":"Wrap loss function loss(batch, θ).\n\nThe function loss should take inputs like loss(f, x, y, θ).\n\n\n\n\n\n","category":"method"},{"location":"#CoupledNODE.create_randloss_MulDtO-Tuple{Any, Any, Any}","page":"Home","title":"CoupledNODE.create_randloss_MulDtO","text":"[DEPRECATED]     createrandlossMulDtO(target; nunroll, nintervals=1, nsamples, λc, λl1)\n\nCreates a random loss function for the multishooting method with multiple shooting intervals.\n\nArguments\n\ntarget: The target data for the loss function.\ntraining_CNODE: Model CNODE.\nst: state of the neural part.\nnunroll: The number of time steps to unroll.\nnoverlaps: The number of time steps that overlaps between consecutive intervals.\nnintervals: The number of shooting intervals.\nnsamples: The number of samples to select.\nλ_c: The weight for the continuity term. It sets how strongly we make the pieces match (continuity term).\nλ_l1: The coefficient for the L1 regularization term in the loss function.\n\nReturns\n\nrandloss_MulDtO: A random loss function for the multishooting method.\n\n\n\n\n\n","category":"method"},{"location":"#CoupledNODE.create_randloss_derivative-NTuple{4, Any}","page":"Home","title":"CoupledNODE.create_randloss_derivative","text":"create_randloss_derivative(input_data, F_target, f, st; n_use = size(input_data, 2), λ=0, λ_c = 0)\n\nCreate a randomized loss function that compares the derivatives. This is done because using the entire dataset at each iteration would be too expensive.\n\nArguments\n\ninput_data: The input data.\nF_target: The target data.\nf: The model function.\nst: The model state.\nn_use: The number of samples to use for the loss function. Defaults to the number of samples in the input data.\nλ and λ_c: The regularization parameter. Defaults to 0.\n\nReturns\n\nA function that computes the mean squared error loss and takes as input the model parameters.\n\n\n\n\n\n","category":"method"},{"location":"#CoupledNODE.decollocate-Tuple{Any}","page":"Home","title":"CoupledNODE.decollocate","text":"Interpolate closure force from volume centers to volume faces.\n\n\n\n\n\n","category":"method"},{"location":"#CoupledNODE.interpolate-Tuple{Any, Any, Any}","page":"Home","title":"CoupledNODE.interpolate","text":"Interpolate velocity components to volume centers.\n\nTODO, D and dir can be parameters istead of arguments I think\n\n\n\n\n\n","category":"method"},{"location":"#CoupledNODE.loss_MulDtO_oneset-NTuple{4, Any}","page":"Home","title":"CoupledNODE.loss_MulDtO_oneset","text":"[DEPRECATED]     lossMulDtOoneset(trajectory, θ; λc=1e1, λl1=1e1, nunroll, nintervals, nsamples=nsamples)\n\nCompute the loss function for the multiple shooting method with a continuous neural ODE (CNODE) model. Check https://docs.sciml.ai/DiffEqFlux/dev/examples/multiple_shooting/ for more details.\n\nArguments\n\ntrajectory: The trajectory of the system.\nθ: The parameters of the CNODE model.\ntraining_CNODE: Model CNODE.\nλ_c: The weight for the continuity term. It sets how strongly we make the pieces match (continuity term). Default is 1e1.\nλ_l1: The weight for the L1 regularization term. Default is 1e1.\nnunroll: The number of time steps to unroll the trajectory.\nnoverlaps: The number of time steps that overlaps between each consecutive intervals.\nnintervals: The number of intervals to divide the trajectory into.\nnsamples: The number of samples.\n\nReturns\n\nloss: The computed loss value.\n\n\n\n\n\n","category":"method"},{"location":"#CoupledNODE.loss_posteriori_optim-NTuple{4, Any}","page":"Home","title":"CoupledNODE.loss_posteriori_optim","text":"loss_posteriori_optim(model, p, st, dataloader)\n\nCompute the loss function for a-posteriori fitting using the given model, parameters, state, and dataloader. This function is compatible with training via Optim.jl.\n\nArguments\n\nmodel: The model to evaluate.\np: Parameters for the model.\nst: State of the model.\ndataloader::Function: A function that returns the data (u, t).\n\nReturns\n\nloss: The computed loss value.\n\n\n\n\n\n","category":"method"},{"location":"#CoupledNODE.loss_priori_lux-NTuple{4, Any}","page":"Home","title":"CoupledNODE.loss_priori_lux","text":"loss_priori_lux(model, ps, st, (x, y))\n\nCompute the loss  as the sum of squared differences between the predicted values and the target values, normalized by the sum of squared target values. Format of function signature and outputs are compatible with the Lux ecosystem.\n\nArguments\n\nmodel: The model to be evaluated.\nps: Parameters for the model.\nst: State of the model.\n(x, y): A tuple where x is the input data and y is the target data.\n\nReturns\n\nloss: The computed loss value.\nst_: The updated state of the model.\n(; y_pred = y_pred): Named tuple containing the predicted values y_pred.\n\n\n\n\n\n","category":"method"},{"location":"#CoupledNODE.mean_squared_error-NTuple{4, Any}","page":"Home","title":"CoupledNODE.mean_squared_error","text":"Compute MSE between f(x, θ, st) and y. The MSE is further divided by normalize(y). This signature has been chosen for compatibility with Lux.\n\n\n\n\n\n","category":"method"},{"location":"#CoupledNODE.mean_squared_error-NTuple{7, Any}","page":"Home","title":"CoupledNODE.mean_squared_error","text":"mean_squared_error(f, st, x, y, θ, λ)\n\nRandom a priori loss function. Use this function to train the closure term to reproduce the right hand side.\n\nArguments:\n\nf: Function that represents the model.\nst: State of the model.\nx: Input data.\ny: Target data.\nθ: Parameters of the model.\nλ and λ_c: Regularization parameters.\n\nReturns:\n\ntotal_loss: Mean squared error loss.\n\n\n\n\n\n","category":"method"},{"location":"#CoupledNODE.validate_results","page":"Home","title":"CoupledNODE.validate_results","text":"validate_results(model, p, dataloader, nuse = 100)\n\nValidate the results of the model using the given parameters p, dataloader, and number of samples nuse.\n\nArguments\n\nmodel: The model to evaluate.\np: Parameters for the model.\ndataloader::Function: A function that returns the data (u, t).\nnuse::Int: The number of samples to use for validation. Defaults to 100.\n\nReturns\n\nloss: The computed loss value.\n\n\n\n\n\n","category":"function"}]
}
