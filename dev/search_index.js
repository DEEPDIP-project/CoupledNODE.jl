var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = CoupledNODE","category":"page"},{"location":"#CoupledNODE","page":"Home","title":"CoupledNODE","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for CoupledNODE.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [CoupledNODE, CoupledNODE.NavierStokes]","category":"page"},{"location":"#CoupledNODE.lhist","page":"Home","title":"CoupledNODE.lhist","text":"callback(p, l, pred; doplot=true)\n\nThe callback function is used to observe training progress. It prints the current loss value and updates the rolling average of the loss. If do_plot is true, it also plots the rolling average of the loss every 10 steps.\n\nArguments\n\np: the current parameters\nl: the current loss value\npred: the current prediction\ndo_plot: a boolean indicating whether to plot the rolling average of the loss every 10 steps (default is true)\n\nReturns\n\nfalse if nothing unexpected happened.\n\n\n\n\n\n","category":"constant"},{"location":"#CoupledNODE.cnn-Tuple{}","page":"Home","title":"CoupledNODE.cnn","text":"cnn(; setup, radii, channels, activations, use_bias, channel_augmenter = identity, rng = Random.default_rng())\n\nConstructs a convolutional neural network model closure(u, θ) that predicts the commutator error (i.e. closure).\n\nArguments\n\nsetup: IncompressibleNavierStokes.jl setup\nradii: An array (size n_layers) with the radii of the kernels for the convolutional layers. Kernels will be symmetrical of size 2r+1.\nchannels: An array (size n_layers) with channel sizes for the convolutional layers.\nactivations: An array (size n_layers) with activation functions for the convolutional layers.\nuse_bias: An array (size n_layers) with booleans indicating whether to use bias in each convolutional layer.\nrng: A random number generator (default: Random.default_rng()).\n\nReturns\n\nA tuple (chain, params, state) where\n\nchain: The constructed Lux.Chain model.\nparams: The parameters of the model.\nstate: The state of the model.\n\n\n\n\n\n","category":"method"},{"location":"#CoupledNODE.collocate-Tuple{Any}","page":"Home","title":"CoupledNODE.collocate","text":"Interpolate velocity components to volume centers.\n\n\n\n\n\n","category":"method"},{"location":"#CoupledNODE.create_loss_post_lux-Tuple{Any}","page":"Home","title":"CoupledNODE.create_loss_post_lux","text":"create_loss_post_lux(rhs; sciml_solver = Tsit5(), kwargs...)\n\nCreates a loss function for a-posteriori fitting using the given right-hand side (RHS) function rhs. The loss function computes the sum of squared differences between the predicted values and the actual data,  normalized by the sum of squared actual data values.\n\nArguments\n\nrhs::Function: The right-hand side function for the ODE problem.\nsciml_solver::AbstractODEAlgorithm: (Optional) The SciML solver to use for solving the ODE problem. Defaults to Tsit5().\nkwargs...: Additional keyword arguments to pass to the solver.\n\nReturns\n\nloss_function::Function: A function that computes the loss given a model, parameters, state, and data (u, t).\n\nloss_function Arguments\n\nmodel: The model to evaluate.\nps: Parameters for the model.\nst: State of the model.\n(u, t): Tuple containing the data u and time points t.\n\nloss_function Returns\n\nloss: The computed loss value.\nst: The model state (unchanged).\nmetadata::NamedTuple: A named tuple containing the predicted values y_pred.\n\nThis makes it compatible with the Lux ecosystem.\n\n\n\n\n\n","category":"method"},{"location":"#CoupledNODE.create_loss_priori-Tuple{Any, Any}","page":"Home","title":"CoupledNODE.create_loss_priori","text":"Wrap loss function loss(batch, θ).\n\nThe function loss should take inputs like loss(f, x, y, θ).\n\n\n\n\n\n","category":"method"},{"location":"#CoupledNODE.create_randloss_MulDtO-Tuple{Any, Any, Any}","page":"Home","title":"CoupledNODE.create_randloss_MulDtO","text":"create_randloss_MulDtO(target; nunroll, nintervals=1, nsamples, λ_c, λ_l1)\n\nCreates a random loss function for the multishooting method with multiple shooting intervals.\n\nArguments\n\ntarget: The target data for the loss function.\ntraining_CNODE: Model CNODE.\nst: state of the neural part.\nnunroll: The number of time steps to unroll.\nnoverlaps: The number of time steps that overlaps between consecutive intervals.\nnintervals: The number of shooting intervals.\nnsamples: The number of samples to select.\nλ_c: The weight for the continuity term. It sets how strongly we make the pieces match (continuity term).\nλ_l1: The coefficient for the L1 regularization term in the loss function.\n\nReturns\n\nrandloss_MulDtO: A random loss function for the multishooting method.\n\n\n\n\n\n","category":"method"},{"location":"#CoupledNODE.create_randloss_derivative-NTuple{4, Any}","page":"Home","title":"CoupledNODE.create_randloss_derivative","text":"create_randloss_derivative(input_data, F_target, f, st; n_use = size(input_data, 2), λ=0, λ_c = 0)\n\nCreate a randomized loss function that compares the derivatives. This is done because using the entire dataset at each iteration would be too expensive.\n\nArguments\n\ninput_data: The input data.\nF_target: The target data.\nf: The model function.\nst: The model state.\nn_use: The number of samples to use for the loss function. Defaults to the number of samples in the input data.\nλ and λ_c: The regularization parameter. Defaults to 0.\n\nReturns\n\nA function that computes the mean squared error loss and takes as input the model parameters.\n\n\n\n\n\n","category":"method"},{"location":"#CoupledNODE.decollocate-Tuple{Any}","page":"Home","title":"CoupledNODE.decollocate","text":"Interpolate closure force from volume centers to volume faces.\n\n\n\n\n\n","category":"method"},{"location":"#CoupledNODE.loss_MulDtO_oneset-NTuple{4, Any}","page":"Home","title":"CoupledNODE.loss_MulDtO_oneset","text":"loss_MulDtO_oneset(trajectory, θ; λ_c=1e1, λ_l1=1e1, nunroll, nintervals, nsamples=nsamples)\n\nCompute the loss function for the multiple shooting method with a continuous neural ODE (CNODE) model. Check https://docs.sciml.ai/DiffEqFlux/dev/examples/multiple_shooting/ for more details.\n\nArguments\n\ntrajectory: The trajectory of the system.\nθ: The parameters of the CNODE model.\ntraining_CNODE: Model CNODE.\nλ_c: The weight for the continuity term. It sets how strongly we make the pieces match (continuity term). Default is 1e1.\nλ_l1: The weight for the L1 regularization term. Default is 1e1.\nnunroll: The number of time steps to unroll the trajectory.\nnoverlaps: The number of time steps that overlaps between each consecutive intervals.\nnintervals: The number of intervals to divide the trajectory into.\nnsamples: The number of samples.\n\nReturns\n\nloss: The computed loss value.\n\n\n\n\n\n","category":"method"},{"location":"#CoupledNODE.loss_priori_lux-NTuple{4, Any}","page":"Home","title":"CoupledNODE.loss_priori_lux","text":"loss_priori_lux(model, ps, st, (x, y))\n\nCompute the loss  as the sum of squared differences between the predicted values and the target values, normalized by the sum of squared target values. Format of function signature and outputs are compatible with the Lux ecosystem.\n\nArguments\n\nmodel: The model to be evaluated.\nps: Parameters for the model.\nst: State of the model.\n(x, y): A tuple where x is the input data and y is the target data.\n\nReturns\n\nloss: The computed loss value.\nst_: The updated state of the model.\n(; y_pred = y_pred): Named tuple containing the predicted values y_pred.\n\n\n\n\n\n","category":"method"},{"location":"#CoupledNODE.mean_squared_error-NTuple{4, Any}","page":"Home","title":"CoupledNODE.mean_squared_error","text":"Compute MSE between f(x, θ, st) and y. The MSE is further divided by normalize(y). This signature has been chosen for compatibility with Lux.\n\n\n\n\n\n","category":"method"},{"location":"#CoupledNODE.mean_squared_error-NTuple{7, Any}","page":"Home","title":"CoupledNODE.mean_squared_error","text":"mean_squared_error(f, st, x, y, θ, λ)\n\nRandom a priori loss function. Use this function to train the closure term to reproduce the right hand side.\n\nArguments:\n\nf: Function that represents the model.\nst: State of the model.\nx: Input data.\ny: Target data.\nθ: Parameters of the model.\nλ and λ_c: Regularization parameters.\n\nReturns:\n\ntotal_loss: Mean squared error loss.\n\n\n\n\n\n","category":"method"},{"location":"#CoupledNODE.predict_u_CNODE-NTuple{6, Any}","page":"Home","title":"CoupledNODE.predict_u_CNODE","text":"predict_u_CNODE(uv0, θ, st, nunroll, training_CNODE, tg)\n\nAuxiliary function to solve the NeuralODE. Returns the prediction and the target sliced to nunroll time steps for convenience when calculating the loss.\n\nArguments\n\nuv0: Initial condition(s) for the NeuralODE.\nθ: Parameters of the NeuralODE.\nst: Time steps for the NeuralODE.\nnunroll: Number of time steps in the window.\ntraining_CNODE: CNODE model that solves the NeuralODE.\ntg: Target values.\n\nReturns\n\nsol: Prediction of the NeuralODE sliced to nunroll time steps.\ntg[:, :, 1:nunroll]: Target values sliced to nunroll time steps.\n\n\n\n\n\n","category":"method"},{"location":"#CoupledNODE.NavierStokes.INS_to_NN-Tuple{Any}","page":"Home","title":"CoupledNODE.NavierStokes.INS_to_NN","text":"INS_to_NN(u, setup)\n\nConverts the input velocity field u from the IncompressibleNavierStokes.jl style u[time step]=(ux, uy) to a format suitable for neural network training u[n, n, D, batch].\n\nArguments\n\nu: Velocity field in INS style.\n\nReturns\n\nu: Velocity field converted to a tensor format suitable for neural network training.\n\n\n\n\n\n","category":"method"},{"location":"#CoupledNODE.NavierStokes.IO_padded_to_IO_nopad-Tuple{Any, Any}","page":"Home","title":"CoupledNODE.NavierStokes.IO_padded_to_IO_nopad","text":"IO_padded_to_IO_nopad(io, setups)\n\nCreates a view which is similar to the input of the IO arrays, but without boundaries\n\nArguments\n\nio::NamedTuple : tuple with all arrays with boundaries.\nsetup:: IncompressibleNavierStokes.jl setup.\n\nReturns\n\nio::NamedTuple : tuple with views of all arrays without boundaries.\n\n\n\n\n\n","category":"method"},{"location":"#CoupledNODE.NavierStokes.NN_padded_to_INS-Tuple{Any, Any}","page":"Home","title":"CoupledNODE.NavierStokes.NN_padded_to_INS","text":"NN_padded_to_INS(u, setup)\n\nCreates a view of the input velocity field u from the neural network data style u[n, n, D, <optional timesteps>] to the IncompressibleNavierStokes.jl style (ux, uy). If the <optional timesteps> dimensions has size > 1, an error is thrown.\n\nArguments\n\nu: Velocity field in NN style.\nsetup: IncompressibleNavierStokes.jl setup.\n\nReturns\n\nu: Velocity field view in IncompressibleNavierStokes.jl style.\n\n\n\n\n\n","category":"method"},{"location":"#CoupledNODE.NavierStokes.NN_padded_to_NN_nopad-Tuple{Any, Any}","page":"Home","title":"CoupledNODE.NavierStokes.NN_padded_to_NN_nopad","text":"NN_padded_to_NN_nopad(u, setup)\n\nCreates a view of the input velocity field u from the neural network data style u[n, n, D, batch] but without boundaries.\n\nArguments\n\nu: Velocity field in NN style.\nsetup: IncompressibleNavierStokes.jl setup.\n\nReturns\n\nu: Velocity field view without boundaries.\n\n\n\n\n\n","category":"method"},{"location":"#CoupledNODE.NavierStokes.assert_pad_nopad_similar-Tuple{Any, Any, Any}","page":"Home","title":"CoupledNODE.NavierStokes.assert_pad_nopad_similar","text":"assert_pad_nopad_similar(io_pad,io_nopad,setup)\n\nAsserts that the values of padded and non-padded arrays are similar (boundaries excluded of course)\n\nArguments\n\n-io_pad: Padded array -io_nopad: Non-padded array -setup: IncompressibleNavierStokes.jl setup to determine boundary size\n\nReturns\n\nNone\n\nThrows\n\nAssertionError\n\n\n\n\n\n","category":"method"},{"location":"#CoupledNODE.NavierStokes.copy_INS_to_INS_inplace!-Tuple{Any, Any}","page":"Home","title":"CoupledNODE.NavierStokes.copy_INS_to_INS_inplace!","text":"copy_INS_to_INS_inplace\n\nhelper function to assign in-place to a tuple because I am no julia guru that can one-line this.\n\n\n\n\n\n","category":"method"},{"location":"#CoupledNODE.NavierStokes.create_dataloader_posteriori-Tuple{Any}","page":"Home","title":"CoupledNODE.NavierStokes.create_dataloader_posteriori","text":"create_dataloader_posteriori(io_array; nunroll=10, device=identity, rng)\n\nCreates a dataloader function for a-posteriori fitting from the given io_array.\n\nArguments\n\nio_array: A structure containing the data arrays u and t.\nnunroll: The number of time steps to unroll (default is 10).\nrng: A random number generator.\n\nReturns\n\nA function dataloader that, when called, returns a tuple with:\nu: A view into the u array of io_array for a randomly selected sample and time steps.\nt: The corresponding time steps from the t array of io_array.\n\nNotes\n\nThe io_array.u array is expected to have dimensions (n, n, dim, samples, nt).\nThe nt dimension must be greater than or equal to nunroll.\nHave only tested in 2D cases.\nIt assumes that the data are loaded in batches of size 1\n\n\n\n\n\n","category":"method"},{"location":"#CoupledNODE.NavierStokes.create_dataloader_prior-Tuple{Any}","page":"Home","title":"CoupledNODE.NavierStokes.create_dataloader_prior","text":"create_dataloader_prior(io_array; nunroll=10, device=identity, rng)\n\nCreate dataloader that uses a batch of `batchsize` random samples from\n\ndata at each evaluation.\n\nArguments\n\nio_array: An named tuple with the data arrays u and c.\nbatchsize: The number of samples to use in each batch.\ndevice: A function to move the data to the desired device (e.g. gpu).\n\nReturns\n\nA function dataloader that, when called, returns a tuple with:\nu: baru from `ioarray` (input to NN)\nc: commutator error from io_array (label)\n\n\n\n\n\n","category":"method"},{"location":"#CoupledNODE.NavierStokes.create_io_arrays_posteriori-Tuple{Any, Any}","page":"Home","title":"CoupledNODE.NavierStokes.create_io_arrays_posteriori","text":"create_io_arrays_posteriori(data, setups)\n\nMain differences between this function and NeuralClosure.createioarrays\n\nwe do not need the commutator error c.\nwe need the time and we keep the initial condition.\nput time dimension in the end, since SciML also does.\n\nReturns\n\nA named tuple with fields u and t. u is a matrix without padding and shape (nless..., D, sample, t)\n\n\n\n\n\n","category":"method"},{"location":"#CoupledNODE.NavierStokes.create_io_arrays_priori-Tuple{Any, Any}","page":"Home","title":"CoupledNODE.NavierStokes.create_io_arrays_priori","text":"create_io_arrays_priori(data, setups)\n\nCreate (baru c) pairs for training.\n\nReturns\n\nA named tuple with fields u and c. (without boundary conditions padding)\n\n\n\n\n\n","category":"method"},{"location":"#CoupledNODE.NavierStokes.create_right_hand_side-Tuple{Any, Any}","page":"Home","title":"CoupledNODE.NavierStokes.create_right_hand_side","text":"create_right_hand_side(setup, psolver)\n\nCreate right hand side function f(u, p, t) compatible with the OrdinaryDiffEq ODE solvers. Note that u has to be an array. To convert the tuple u = (ux, uy) to an array, use stack(u).\n\n\n\n\n\n","category":"method"},{"location":"#CoupledNODE.NavierStokes.create_right_hand_side_inplace-Tuple{Any, Any}","page":"Home","title":"CoupledNODE.NavierStokes.create_right_hand_side_inplace","text":"create_right_hand_side_inplace(setup, psolver)\n\nIn place version of create_right_hand_side.\n\n\n\n\n\n","category":"method"},{"location":"#CoupledNODE.NavierStokes.create_right_hand_side_with_closure-NTuple{4, Any}","page":"Home","title":"CoupledNODE.NavierStokes.create_right_hand_side_with_closure","text":"create_right_hand_side_with_closure(setup, psolver, closure, st)\n\nCreate right hand side function f(u, p, t) compatible with SciML ODEProblem. This formulation was the one proved best in Syver's paper i.e. DCF. u has to be an array in the NN style e.g. [n , n, D], with boundary conditions padding.\n\n\n\n\n\n","category":"method"},{"location":"#CoupledNODE.NavierStokes.pad_manual-NTuple{4, Any}","page":"Home","title":"CoupledNODE.NavierStokes.pad_manual","text":"pad_manual(u, D, b_axes, Iu)\n\nManually pads the input array u along each dimension to match the specified axes b_axes using the indices Iu.\n\nArguments\n\nu::Array{T}: The input array to be padded.\nD::Int: The number of dimensions to pad.\nb_axes::Tuple: A tuple containing the axes of the target array b_INS.\nIu::NamedTuple: A named tuple containing the indices for padding with a field indices which is a vector of vectors of indices. (stores in IncompressibleNavierStokes.setup)\n\nReturns\n\nArray{T}: The padded array.\n\n\n\n\n\n","category":"method"},{"location":"#CoupledNODE.NavierStokes.sum_NN_nopad_and_INS-Tuple{Any, Any, Any}","page":"Home","title":"CoupledNODE.NavierStokes.sum_NN_nopad_and_INS","text":"sum_NN_nopad_and_INS(a_NN, b_INS, setup)\n\nSum a neural network output tensor a_NN with an incompressible Navier-Stokes tensor b_INS after padding a_NN to match the dimensions of b_INS.\n\nArguments\n\na_NN::Array{Float32, 4}: A tensor in the NN format, with dimensions (n, n, dim, 1).\nb_INS::Vector{Matrix{Float32}}: A Tuple of matrices (INS format).\nsetup: An IncompressibleNavierStokes.jl setup. \n\nReturns\n\nTuple{Matrix{Float32}}: A tuple of matrices (INS format) where each matrix is the sum of the padded a_NN tensor and the corresponding b_INS matrix.\n\n\n\n\n\n","category":"method"}]
}
