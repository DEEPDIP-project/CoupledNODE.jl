var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = CoupledNODE","category":"page"},{"location":"#CoupledNODE","page":"Home","title":"CoupledNODE","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for CoupledNODE.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [CoupledNODE]","category":"page"},{"location":"#CoupledNODE.lhist","page":"Home","title":"CoupledNODE.lhist","text":"callback(p, l, pred; doplot=true)\n\nThe callback function is used to observe training progress. It prints the current loss value and updates the rolling average of the loss. If do_plot is true, it also plots the rolling average of the loss every 10 steps.\n\nArguments\n\np: the current parameters\nl: the current loss value\npred: the current prediction\ndo_plot: a boolean indicating whether to plot the rolling average of the loss every 10 steps (default is true)\n\nReturns\n\nfalse if nothing unexpected happened.\n\n\n\n\n\n","category":"constant"},{"location":"#CoupledNODE.Grid","page":"Home","title":"CoupledNODE.Grid","text":"struct Grid\n\nThis object contains the grid information.\n\nFields:\n\ndux::Float64: The grid spacing in the x-direction for u.\nduy::Float64: The grid spacing in the y-direction for u.\nnux::Int: The number of grid points in the x-direction for u.\nnuy::Int: The number of grid points in the y-direction for u.\ndvx::Float64: The grid spacing in the x-direction for v.\ndvy::Float64: The grid spacing in the y-direction for v.\nnvx::Int: The number of grid points in the x-direction for v.\nnvy::Int: The number of grid points in the y-direction for v.\nNu::Int: The total number of elements for u.\nNv::Int: The total number of elements for v.\n\nConstructor:\n\nGrid(dux::Float64, duy::Float64, nux::Int, nuy::Int, dvx::Float64, dvy::Float64, nvx::Int, nvy::Int): Constructs a Grid object with the given grid parameters.\n\n\n\n\n\n","category":"type"},{"location":"#CoupledNODE.create_f_CNODE","page":"Home","title":"CoupledNODE.create_f_CNODE","text":"create_f_CNODE(F_u, G_v, grid, NN_u=nothing, NN_v=nothing; is_closed=false)\n\nCreate a neural network model for the Coupled Neural ODE (CNODE) approach.\n\nArguments\n\nF_u: Function that defines the right-hand side of the CNODE for the variable u.\nG_v: Function that defines the right-hand side of the CNODE for the variable v.\ngrid: Grid object that represents the spatial discretization of the variables u and v.\nNN_u (optional): Neural network model for the variable u. Default is nothing.\nNN_v (optional): Neural network model for the variable v. Default is nothing.\nis_closed (optional): Boolean indicating whether the CNODE is closed or not. Default is false.\n\nReturns\n\nThe created CNODE model.\n\n\n\n\n\n","category":"function"},{"location":"#CoupledNODE.create_f_NODE-Tuple{Any, Any}","page":"Home","title":"CoupledNODE.create_f_NODE","text":"create_f_NODE(NN, f_u; is_closed=false)\n\nCreate a Neural ODE (NODE) using ResNet skip blocks to add the closure.\n\nArguments\n\nNN: The neural network model.\nf_u: The closure function.\nis_closed: A boolean indicating whether to add the closure or not. Default is false.\n\nReturns\n\nThe created Neural ODE (NODE) model.\n\n\n\n\n\n","category":"method"},{"location":"#CoupledNODE.create_randloss_MulDtO-Tuple{Any}","page":"Home","title":"CoupledNODE.create_randloss_MulDtO","text":"create_randloss_MulDtO(target; nunroll, nintervals=1, nsamples, λ_c, λ_l1)\n\nCreates a random loss function for the multishooting method with multiple shooting intervals.\n\nArguments\n\ntarget: The target data for the loss function.\nnunroll: The number of time steps to unroll.\nnoverlaps: The number of time steps that overlaps between each consecutive intervals.\nnintervals: The number of shooting intervals.\nnsamples: The number of samples to select.\nλ_c: The weight for the continuity term. It sets how strongly we make the pieces match (continuity term).\nλ_l1: The coefficient for the L1 regularization term in the loss function.\n\nReturns\n\nrandloss_MulDtO: A random loss function for the multishooting method.\n\n\n\n\n\n","category":"method"},{"location":"#CoupledNODE.create_randloss_derivative-NTuple{4, Any}","page":"Home","title":"CoupledNODE.create_randloss_derivative","text":"create_randloss_derivative(GS_data, FG_target, f, st; nuse = size(GS_data, 2), λ=0)\n\nCreate a randomized loss function that compares the derivatives. This function creates a randomized loss function derivative by selecting a subset of the data. This is done because using the entire dataset at each iteration would be too expensive.\n\nArguments\n\nGS_data: The input data.\nFG_target: The target data.\nf: The model function.\nst: The model state.\nnuse: The number of samples to use for the loss function. Defaults to the size of GS_data.\nλ: The regularization parameter. Defaults to 0.\n\nReturns\n\nA function randloss that computes the mean squared error loss using the selected subset of data.\n\n\n\n\n\n","category":"method"},{"location":"#CoupledNODE.downscale_v","page":"Home","title":"CoupledNODE.downscale_v","text":"downscale_v(grid, resize_v=false)\n\nGenerate the layer that downscales v and expects as input a tuple (u, v).  If resize_v is true, the layer upscales v to twice the target size and applies mean pooling.\n\nArguments:\n\ngrid: Grid object that represents the spatial discretization of the variables u and v.\nresize_v: A boolean indicating whether to resize v.\n\nReturns:\n\nFunction that takes a tuple (u, v) returns the linearized concatenation of u and v.\n\n\n\n\n\n","category":"function"},{"location":"#CoupledNODE.loss_MulDtO_oneset-Tuple{Any, Any}","page":"Home","title":"CoupledNODE.loss_MulDtO_oneset","text":"loss_MulDtO_oneset(trajectory, θ; λ_c=1e1, λ_l1=1e1, nunroll, nintervals, nsamples=nsamples)\n\nCompute the loss function for the multiple shooting method with a continuous neural ODE (CNODE) model. Check https://docs.sciml.ai/DiffEqFlux/dev/examples/multiple_shooting/ for more details.\n\nArguments\n\ntrajectory: The trajectory of the system.\nθ: The parameters of the CNODE model.\nλ_c: The weight for the continuity term. It sets how strongly we make the pieces match (continuity term). Default is 1e1.\nλ_l1: The weight for the L1 regularization term. Default is 1e1.\nnunroll: The number of time steps to unroll the trajectory.\nnoverlaps: The number of time steps that overlaps between each consecutive intervals.\nnintervals: The number of intervals to divide the trajectory into.\nnsamples: The number of samples. Default is nsamples.\n\nReturns\n\nloss: The computed loss value.\nnothing: Placeholder return value.\n\n\n\n\n\n","category":"method"},{"location":"#CoupledNODE.mean_squared_error-NTuple{6, Any}","page":"Home","title":"CoupledNODE.mean_squared_error","text":"mean_squared_error(f, st, x, y, θ, λ)\n\nRandom a priori loss function. Use this function to train the closure term to reproduce the right hand side.\n\nArguments:\n\nf: Function that represents the model.\nst: State of the model.\nx: Input data.\ny: Target data.\nθ: Parameters of the model.\nλ: Regularization parameter.\n\nReturns:\n\ntotal_loss: Mean squared error loss.\n\n\n\n\n\n","category":"method"},{"location":"#CoupledNODE.upscale_v","page":"Home","title":"CoupledNODE.upscale_v","text":"upscale_v(grid, resize_v=false)\n\nGenerate the layer that upscales v. This function expects as input the linearized concatenation of u and v and returns a tuple (u, v).\n\nArguments:\n\ngrid: Grid object that represents the spatial discretization of the variables u and v.\nresize_v: A boolean indicating whether to resize the v component.\n\nReturns:\n\nFunction that reshapes u and v on the grid and returns a tuple (u, v)\n\n\n\n\n\n","category":"function"}]
}
