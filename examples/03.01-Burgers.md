```julia
const ArrayType = Array
import DifferentialEquations: Tsit5
const solver_algo = Tsit5()
const MY_TYPE = Float32 # use float32 if you plan to use a GPU
import CUDA # Test if CUDA is running
if CUDA.functional()
    CUDA.allowscalar(false)
    const ArrayType = CuArray
    import DiffEqGPU: GPUTsit5
    const solver_algo = GPUTsit5()
end
```

# Burgers equations
In this example, we will solve the Burgers equation in using the Neural ODEs framework. The Burgers equation is a fundamental equation in fluid dynamics and is given by:
$$
\begin{equation}
\frac{\partial u}{\partial t} = - u \frac{\partial u}{\partial x} + \nu \frac{\partial u^2}{\partial x^2} = f(u)
\end{equation}
$$
where $u(x,t)$ is the velocity of the fluid, $\nu$ is the viscosity coefficient, and $(x,y)$ and $t$ are the spatial and temporal coordinates, respectively. The equation is a non-linear partial differential equation that describes the evolution of a fluid flow in one spatial dimensions. The equation is named after Johannes Martinus Burgers, who introduced it in 1948 as a simplified model for turbulence.

We start by defining the right-hand side of the Burgers equation. We will use the finite difference method to compute the spatial derivatives.
So the first step is to define the grid that we are going to use.
We define a DNS and a LES

```julia
import CoupledNODE: Grid
nux_dns = 500
dux_dns = 2π / nux_dns
grid_u_dns = Grid(dim = 1, dx = dux_dns, nx = nux_dns)
nux_les = 300
dux_les = 2π / nux_les
grid_u_les = Grid(dim = 1, dx = dux_les, nx = nux_les)
```

The following function constructs the right-hand side of the Burgers equation:

```julia
import CoupledNODE: Laplacian, first_derivatives
using Zygote
function create_burgers_rhs(grids, force_params)
    ν = force_params[1]

    function Force(u)
        du_dx = first_derivatives(u, grids[1].dx)
        F = Zygote.@ignore -u .* du_dx +
                           ν * Laplacian(u, grids[1].dx^2)
        return F
    end
    return Force
end
```

Let's set the parameters for the Burgers equation

```julia
ν = 0.01f0
```

and we pack them into a tuple for the rhs Constructor

```julia
force_params = (ν,)
```

we also need to pack the grid into a tuple

```julia
grid_B_dns = (grid_u_dns,)
grid_B_les = (grid_u_les,)
```

Now we can create the right-hand side of the NODE

```julia
F_dns = create_burgers_rhs(grid_B_dns, force_params)
F_les = create_burgers_rhs(grid_B_les, force_params)
```

We can now generate the initial conditions for the Burgers equation. We will use a combination of sine waves and noise to create the initial conditions.

```julia
function generate_initial_conditions(n_samples::Int, grids)
    Nx = grids[1].nx
    x = range(0, stop = 2π, length = Nx)

    u0_list = Array{Float32, 2}(undef, Nx, n_samples)

    for j in 1:n_samples
        u0 = @view u0_list[:, j]
        u0 .= 0.0
```

Randomize the number of sine waves for each sample

```julia
        n_waves = rand(1:3)
        for _ in 1:n_waves
```

Randomize the frequency, amplitude, and phase shift for each sine wave

```julia
            freq = rand() * 2π
            amplitude = rand() * 0.07
            phase_shift = rand() * 2π
            u0 .+= amplitude * sin.(freq .* x .+ phase_shift)
        end
```

Randomize the amount of noise

```julia
        noise_level = rand() * 0.2
        u0 .+= noise_level * randn(Nx)
    end
    return u0_list
end

u0_dns = generate_initial_conditions(10, grid_B_dns)
```

To get the initial condition of the LES we filter the data already generated
(interpolate )

```julia
u0_les =

include("./../coupling_functions/functions_NODE.jl")
f_dns = create_f_CNODE(create_burgers_rhs, force_params, grid_B; is_closed = false);
import Random, LuxCUDA, Lux
rng = Random.seed!(1234)
θ_dns, st_dns = Lux.setup(rng, f_CNODE);
```

The first phase of the Burger solution will be the formation of the shock. We use a small time step to resolve the shock formation.

```julia
import DiffEqFlux: NeuralODE
t_shock = 40.0f0
dt_shock = 0.001f0
trange_burn = (0.0f0, t_shock)
saveat_shock = 0.05f0
dns = NeuralODE(f_dns,
    trange_burn,
    solver_algo,
    adaptive = false,
    dt = dt_shock,
    saveat = saveat_shock);
u_dns = Array(dns(u0_dns, θ_dns, st_dns)[1]);
```

Plot

```julia
using Plots
x = range(0, stop = 2π, length = nux)
anim = Animation()
fig = plot(layout = (4, 1), size = (300, 700))
@gif for i in 1:2:size(u_shock, 3)
    p1 = plot(x, u_dns[:, 1, i], xlabel = "x", ylabel = "u", legend = false)
    p2 = plot(x, u_dns[:, 2, i], xlabel = "x", ylabel = "u", legend = false)
    p3 = plot(x, u_dns[:, 3, i], xlabel = "x", ylabel = "u", legend = false)
    p4 = plot(x, u_dns[:, 4, i], xlabel = "x", ylabel = "u", legend = false)
    title = "Time: $(round((i - 1) * dt_shock, digits = 2))"
    fig = plot(p1, p2, p3, p4, layout = (4, 1), title = title)
    frame(anim, fig)
end
if isdir("./plots")
    gif(anim, "plots/03.01_Burgers.gif", fps = 12)
else
    gif(anim, "examples/plots/03.01_Burgers.gif", fps = 12)
end
```

Do a high res
Do a low res
filter the low res and compare

## Energy

PDEs like the Burgers equation conserve energy. If we discretize the Burgers equation the energy conservation takes the following form:
$$
\begin{equation}
\frac{dE}{dt} = \bm{u}^T \bm{\omega} f(\bm{u})
\end{equation}
$$
where $E$ is the energy of the system given by:
$$
\begin{equation}
E = \frac{1}{2} \bm{u}^T \bm{\omega} \bm{u},
\end{equation}
$$
and $\bm{\omega} \in \mathbb{R}^{N\times N}$ is the grid volumes of the diagonal elements.
In a dissipative system as Burgers equation, the energy will decrease over time. We can compute the energy of the system at each time step and plot it to verify that the energy is decreasing.

---

*This page was generated using [Literate.jl](https://github.com/fredrikekre/Literate.jl).*

